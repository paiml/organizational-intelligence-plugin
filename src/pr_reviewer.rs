// src/pr_reviewer.rs
//! Fast PR review using stateful baselines (<30s feedback)
//!
//! This module provides PR review capabilities that avoid overburden (Muri) by:
//! - Loading pre-computed organizational baselines (expensive, run weekly)
//! - Analyzing only changed files (cheap, <30s per PR)
//! - Generating actionable warnings based on historical patterns

use crate::summarizer::Summary;
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::Path;

/// Warning generated for a specific file in the PR
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PrWarning {
    /// File that triggered the warning
    pub file: String,
    /// Defect category (e.g., "ConfigurationErrors")
    pub category: String,
    /// Human-readable warning message
    pub message: String,
    /// Actionable prevention tips
    pub prevention_tips: Vec<String>,
    /// Historical frequency of this defect type
    pub frequency: usize,
    /// Average TDG score for this category
    pub avg_tdg_score: f32,
}

/// Complete review results for a PR
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrReview {
    /// Warnings generated by pattern matching
    pub warnings: Vec<PrWarning>,
    /// Baseline metadata
    pub baseline_date: String,
    /// Number of repositories in baseline analysis
    pub repositories_analyzed: usize,
    /// Files analyzed in this PR
    pub files_analyzed: Vec<String>,
}

impl PrReview {
    /// Generate markdown report suitable for GitHub comments
    pub fn to_markdown(&self) -> String {
        let mut output = String::new();

        output.push_str("# PR Review: Organizational Intelligence\n\n");

        if self.warnings.is_empty() {
            output.push_str("✅ **No warnings** - No files match historical defect patterns.\n\n");
        } else {
            output.push_str(&format!(
                "## ⚠️ {} Warning{} Based on Historical Patterns\n\n",
                self.warnings.len(),
                if self.warnings.len() == 1 { "" } else { "s" }
            ));

            for warning in &self.warnings {
                output.push_str(&format!("### {}\n", warning.file));
                output.push_str(&format!(
                    "**Category**: {} ({} occurrences, TDG: {:.1})\n\n",
                    warning.category, warning.frequency, warning.avg_tdg_score
                ));
                output.push_str(&format!("{}\n\n", warning.message));

                if !warning.prevention_tips.is_empty() {
                    output.push_str("**Prevention Strategies**:\n");
                    for tip in &warning.prevention_tips {
                        output.push_str(&format!("- ✅ {}\n", tip));
                    }
                    output.push('\n');
                }

                output.push_str("---\n\n");
            }
        }

        output.push_str(&format!(
            "**Analysis Date**: {} (baseline is from {} repositories)\n",
            self.baseline_date, self.repositories_analyzed
        ));
        output.push_str(&format!(
            "**Files Analyzed**: {}\n",
            self.files_analyzed.len()
        ));

        output
    }

    /// Generate JSON report for programmatic consumption
    pub fn to_json(&self) -> Result<String> {
        serde_json::to_string_pretty(self).context("Failed to serialize PR review to JSON")
    }
}

/// Fast PR reviewer using pre-computed baselines
pub struct PrReviewer {
    baseline: Summary,
}

impl PrReviewer {
    /// Load baseline summary from weekly analysis
    pub fn load_baseline<P: AsRef<Path>>(path: P) -> Result<Self> {
        let baseline =
            Summary::from_file(path.as_ref()).context("Failed to load baseline summary")?;
        Ok(Self { baseline })
    }

    /// Review PR files against organizational defect patterns
    pub fn review_pr(&self, files_changed: &[String]) -> PrReview {
        let mut warnings = Vec::new();

        for file in files_changed {
            // Check file type against defect patterns
            let file_warnings = self.check_file_patterns(file);
            warnings.extend(file_warnings);
        }

        PrReview {
            warnings,
            baseline_date: self.baseline.metadata.analysis_date.clone(),
            repositories_analyzed: self.baseline.metadata.repositories_analyzed,
            files_analyzed: files_changed.to_vec(),
        }
    }

    /// Check a single file against all defect patterns
    fn check_file_patterns(&self, file: &str) -> Vec<PrWarning> {
        let mut warnings = Vec::new();

        // Configuration files (YAML, TOML, JSON)
        if is_config_file(file) {
            if let Some(pattern) = self.baseline.find_category("ConfigurationErrors") {
                if should_warn(&pattern) {
                    warnings.push(PrWarning {
                        file: file.to_string(),
                        category: pattern.category.clone(),
                        message: format!(
                            "This org has {} config errors (avg TDG: {:.1}). Ensure validation!",
                            pattern.frequency, pattern.avg_tdg_score
                        ),
                        prevention_tips: pattern.prevention_strategies.clone(),
                        frequency: pattern.frequency,
                        avg_tdg_score: pattern.avg_tdg_score,
                    });
                }
            }
        }

        // API/integration files (contains "api", "client", "http")
        if is_integration_file(file) {
            if let Some(pattern) = self.baseline.find_category("IntegrationFailures") {
                if should_warn(&pattern) {
                    warnings.push(PrWarning {
                        file: file.to_string(),
                        category: pattern.category.clone(),
                        message: format!(
                            "Integration issues detected {} times (avg TDG: {:.1}). Check timeouts and retries!",
                            pattern.frequency, pattern.avg_tdg_score
                        ),
                        prevention_tips: pattern.prevention_strategies.clone(),
                        frequency: pattern.frequency,
                        avg_tdg_score: pattern.avg_tdg_score,
                    });
                }
            }
        }

        // Logic-heavy files (common code file extensions)
        if is_code_file(file) {
            if let Some(pattern) = self.baseline.find_category("LogicErrors") {
                if should_warn(&pattern) {
                    warnings.push(PrWarning {
                        file: file.to_string(),
                        category: pattern.category.clone(),
                        message: format!(
                            "Logic errors occurred {} times (avg TDG: {:.1}). Test edge cases!",
                            pattern.frequency, pattern.avg_tdg_score
                        ),
                        prevention_tips: pattern.prevention_strategies.clone(),
                        frequency: pattern.frequency,
                        avg_tdg_score: pattern.avg_tdg_score,
                    });
                }
            }
        }

        warnings
    }
}

/// Check if file is a configuration file
fn is_config_file(file: &str) -> bool {
    file.ends_with(".yaml")
        || file.ends_with(".yml")
        || file.ends_with(".toml")
        || file.ends_with(".json")
        || file.ends_with(".env")
        || file.ends_with(".config")
        || file.ends_with(".ini")
}

/// Check if file is related to API/integration
fn is_integration_file(file: &str) -> bool {
    let lower = file.to_lowercase();
    lower.contains("api")
        || lower.contains("client")
        || lower.contains("http")
        || lower.contains("integration")
        || lower.contains("service")
}

/// Check if file is a code file (not config, docs, etc.)
fn is_code_file(file: &str) -> bool {
    file.ends_with(".rs")
        || file.ends_with(".py")
        || file.ends_with(".js")
        || file.ends_with(".ts")
        || file.ends_with(".java")
        || file.ends_with(".go")
        || file.ends_with(".cpp")
        || file.ends_with(".c")
        || file.ends_with(".rb")
        || file.ends_with(".php")
}

/// Determine if a defect pattern should trigger a warning
fn should_warn(pattern: &crate::summarizer::DefectPatternSummary) -> bool {
    // Warn if:
    // 1. High frequency (10+ occurrences) AND low quality (TDG < 60)
    // OR
    // 2. Very high frequency (20+ occurrences) regardless of quality
    (pattern.frequency >= 10 && pattern.avg_tdg_score < 60.0) || pattern.frequency >= 20
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::summarizer::{QualityThresholds, SummaryMetadata};

    fn create_test_summary() -> Summary {
        use crate::classifier::DefectCategory;
        use crate::report::{DefectPattern, QualitySignals};
        use crate::summarizer::OrganizationalInsights;

        Summary {
            organizational_insights: OrganizationalInsights {
                top_defect_categories: vec![
                    DefectPattern {
                        category: DefectCategory::ConfigurationErrors,
                        frequency: 25,
                        confidence: 0.78,
                        quality_signals: QualitySignals {
                            avg_tdg_score: Some(45.2),
                            max_tdg_score: Some(60.0),
                            avg_complexity: Some(8.0),
                            avg_test_coverage: Some(0.5),
                            satd_instances: 5,
                            avg_lines_changed: 10.0,
                            avg_files_per_commit: 2.0,
                        },
                        examples: vec![],
                    },
                    DefectPattern {
                        category: DefectCategory::IntegrationFailures,
                        frequency: 18,
                        confidence: 0.82,
                        quality_signals: QualitySignals {
                            avg_tdg_score: Some(52.3),
                            max_tdg_score: Some(70.0),
                            avg_complexity: Some(6.0),
                            avg_test_coverage: Some(0.6),
                            satd_instances: 3,
                            avg_lines_changed: 15.0,
                            avg_files_per_commit: 3.0,
                        },
                        examples: vec![],
                    },
                    DefectPattern {
                        category: DefectCategory::LogicErrors,
                        frequency: 5, // Low frequency
                        confidence: 0.91,
                        quality_signals: QualitySignals {
                            avg_tdg_score: Some(88.5),
                            max_tdg_score: Some(95.0),
                            avg_complexity: Some(4.0),
                            avg_test_coverage: Some(0.85),
                            satd_instances: 0,
                            avg_lines_changed: 8.0,
                            avg_files_per_commit: 1.5,
                        },
                        examples: vec![],
                    },
                ],
            },
            code_quality_thresholds: QualityThresholds::default(),
            metadata: SummaryMetadata {
                analysis_date: "2025-11-15".to_string(),
                repositories_analyzed: 25,
                commits_analyzed: 2500,
            },
        }
    }

    #[test]
    fn test_config_file_triggers_warning() {
        let summary = create_test_summary();
        let reviewer = PrReviewer { baseline: summary };

        let review = reviewer.review_pr(&["config.yaml".to_string()]);

        assert_eq!(review.warnings.len(), 1);
        assert_eq!(review.warnings[0].category, "ConfigurationErrors");
        assert_eq!(review.warnings[0].file, "config.yaml");
        assert_eq!(review.warnings[0].frequency, 25);
    }

    #[test]
    fn test_integration_file_triggers_warning() {
        let summary = create_test_summary();
        let reviewer = PrReviewer { baseline: summary };

        let review = reviewer.review_pr(&["src/api_client.rs".to_string()]);

        // Should get IntegrationFailures warning (not LogicErrors - frequency too low)
        assert_eq!(review.warnings.len(), 1);
        let integration_warning = &review.warnings[0];
        assert_eq!(integration_warning.category, "IntegrationFailures");
        assert_eq!(integration_warning.file, "src/api_client.rs");
    }

    #[test]
    fn test_low_frequency_no_warning() {
        let summary = create_test_summary();
        let reviewer = PrReviewer { baseline: summary };

        // LogicErrors has frequency=5, which is below threshold
        let review = reviewer.review_pr(&["src/logic.rs".to_string()]);

        // Should not get LogicErrors warning (frequency too low)
        let logic_warnings: Vec<_> = review
            .warnings
            .iter()
            .filter(|w| w.category == "LogicErrors")
            .collect();
        assert_eq!(logic_warnings.len(), 0);
    }

    #[test]
    fn test_no_warnings_for_unmatched_files() {
        let summary = create_test_summary();
        let reviewer = PrReviewer { baseline: summary };

        let review = reviewer.review_pr(&["README.md".to_string()]);

        assert_eq!(review.warnings.len(), 0);
    }

    #[test]
    fn test_multiple_files_multiple_warnings() {
        let summary = create_test_summary();
        let reviewer = PrReviewer { baseline: summary };

        let review = reviewer.review_pr(&[
            "config.yaml".to_string(),
            "src/api.rs".to_string(),
            "README.md".to_string(),
        ]);

        // config.yaml -> ConfigurationErrors
        // src/api.rs -> IntegrationFailures (has "api")
        // README.md -> no warnings
        assert!(review.warnings.len() >= 2);
        assert_eq!(review.files_analyzed.len(), 3);
    }

    #[test]
    fn test_markdown_output_with_warnings() {
        let summary = create_test_summary();
        let reviewer = PrReviewer { baseline: summary };

        let review = reviewer.review_pr(&["config.toml".to_string()]);
        let markdown = review.to_markdown();

        assert!(markdown.contains("# PR Review"));
        assert!(markdown.contains("ConfigurationErrors"));
        assert!(markdown.contains("config.toml"));
        // Prevention tips are empty in test data, so we just check structure
        assert!(markdown.contains("Warning"));
    }

    #[test]
    fn test_markdown_output_no_warnings() {
        let summary = create_test_summary();
        let reviewer = PrReviewer { baseline: summary };

        let review = reviewer.review_pr(&["README.md".to_string()]);
        let markdown = review.to_markdown();

        assert!(markdown.contains("No warnings"));
    }

    #[test]
    fn test_json_output() {
        let summary = create_test_summary();
        let reviewer = PrReviewer { baseline: summary };

        let review = reviewer.review_pr(&["config.yaml".to_string()]);
        let json = review.to_json().expect("Should serialize to JSON");

        assert!(json.contains("ConfigurationErrors"));
        assert!(json.contains("warnings"));
    }

    #[test]
    fn test_file_type_detection() {
        assert!(is_config_file("app.yaml"));
        assert!(is_config_file("config.toml"));
        assert!(is_config_file("settings.json"));
        assert!(!is_config_file("main.rs"));

        assert!(is_integration_file("api_client.rs"));
        assert!(is_integration_file("http_service.go"));
        assert!(!is_integration_file("main.rs"));

        assert!(is_code_file("main.rs"));
        assert!(is_code_file("app.py"));
        assert!(!is_code_file("README.md"));
    }
}
